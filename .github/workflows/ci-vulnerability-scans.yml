# GitHub Actions CI workflow that runs vulnerability scans on the application's Docker image
# to ensure images built are secure before they are deployed.

name: CI Vulnerability Scans

# test comment

on:
  push:
    branches:
      - main
    paths:
      - frontend/**
      - .grype.yml
      - .hadolint.yaml
      - .trivyignore
      - .github/workflows/ci-vulnerability-scans.yml
  pull_request:
    paths:
      - frontend/**
      - .grype.yml
      - .hadolint.yaml
      - .trivyignore
      - .github/workflows/ci-vulnerability-scans.yml

env:
  APP_NAME: frontend

jobs:
  hadolint-scan:
    name: Hadolint Scan
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      # Scans Dockerfile for any bad practices or issues
      - name: Scan Dockerfile by hadolint
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: frontend/Dockerfile
          format: tty
          failure-threshold: warning
          output-file: hadolint-results.txt

      - name: Save output to workflow summary
        if: always() # Runs even if there is a failure
        run: |
          cat hadolint-results.txt >> $GITHUB_STEP_SUMMARY

  build-and-cache:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.shared-output.outputs.image }}

    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@master

      - name: Cache Docker layers
        id: cache-buildx
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Ensure Buildx cache exists
        run: |
          mkdir -p /tmp/.buildx-cache

      - name: Set shared outputs
        id: shared-output
        run: |
          IMAGE_NAME=$(make APP_NAME=${{env.APP_NAME}} release-image-name)
          IMAGE_TAG=$(make release-image-tag)
          echo "image=$IMAGE_NAME:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and tag Docker image for scanning
        # If there's an exact match in cache, skip build entirely
        if: steps.cache-buildx.outputs.cache-hit != 'true'
        run: |
          make APP_NAME=${{ env.APP_NAME }} release-build

      - name: Save Docker image
        if: steps.cache-buildx.outputs.cache-hit != 'true'
        run: |
          docker save ${{ steps.shared-output.outputs.image }} > /tmp/docker-image.tar

      - name: Cache Docker image
        if: steps.cache-buildx.outputs.cache-hit != 'true'
        uses: actions/cache/save@v3
        with:
          path: /tmp/docker-image.tar
          key: ${{ runner.os }}-docker-image-${{ github.sha }}

  trivy-scan:
    name: Trivy Scan
    runs-on: ubuntu-latest
    needs: build-and-cache

    steps:
      - uses: actions/checkout@v3

      - name: Restore cached Docker image
        uses: actions/cache/restore@v3
        with:
          path: /tmp/docker-image.tar
          key: ${{ runner.os }}-docker-image-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-docker-image-

      - name: Load cached Docker image
        run: |
          docker load < /tmp/docker-image.tar

      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: image
          image-ref: ${{ needs.build-and-cache.outputs.image }}
          format: table
          exit-code: 1
          ignore-unfixed: true
          vuln-type: os
          scanners: vuln,secret

      - name: Save output to workflow summary
        if: always() # Runs even if there is a failure
        run: |
          echo "View results in GitHub Action logs" >> $GITHUB_STEP_SUMMARY

  anchore-scan:
    name: Anchore Scan
    runs-on: ubuntu-latest
    needs: build-and-cache

    steps:
      - uses: actions/checkout@v3

      - name: Restore cached Docker image
        uses: actions/cache/restore@v3
        with:
          path: /tmp/docker-image.tar
          key: ${{ runner.os }}-docker-image-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-docker-image-

      - name: Load cached Docker image
        run: |
          docker load < /tmp/docker-image.tar

      - name: Run Anchore vulnerability scan
        uses: anchore/scan-action@v3
        with:
          image: ${{ needs.build-and-cache.outputs.image }}
          output-format: table

      - name: Save output to workflow summary
        if: always() # Runs even if there is a failure
        run: |
          echo "View results in GitHub Action logs" >> $GITHUB_STEP_SUMMARY

  dockle-scan:
    name: Dockle Scan
    runs-on: ubuntu-latest
    needs: build-and-cache

    steps:
      - uses: actions/checkout@v3

      - name: Restore cached Docker image
        uses: actions/cache/restore@v3
        with:
          path: /tmp/docker-image.tar
          key: ${{ runner.os }}-docker-image-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-docker-image-

      - name: Load cached Docker image
        run: |
          docker load < /tmp/docker-image.tar

      # Dockle doesn't allow you to have an ignore file for the DOCKLE_ACCEPT_FILES
      # variable, this will save the variable in this file to env for Dockle
      - name: Set any acceptable Dockle files
        run: |
          if grep -q "^DOCKLE_ACCEPT_FILES=.*" .dockleconfig; then
            grep -s '^DOCKLE_ACCEPT_FILES=' .dockleconfig >> $GITHUB_ENV
          fi

      - name: Run Dockle container linter
        uses: erzz/dockle-action@v1.3.1
        with:
          image: ${{ needs.build-and-cache.outputs.image }}
          exit-code: "1"
          failure-threshold: WARN
          accept-filenames: ${{ env.DOCKLE_ACCEPT_FILES }}

      - name: Save output to workflow summary
        if: always() # Runs even if there is a failure
        run: |
          echo "```json" >> $GITHUB_STEP_SUMMARY
          cat dockle-report.json >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
